<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[main_vault]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>main_vault</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 19 Jan 2026 14:26:14 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 19 Jan 2026 14:24:56 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Boolean functions]]></title><description><![CDATA[
Let , then a Boolean function is a function The set of such functions is noted as . let then we define the evaluation of to be the vector
where is equipped with a fixed order for let then we define the weight of to be
where the right hand side is the <a data-tooltip-position="top" aria-label="Hamming distance" data-href="Hamming distance" href="05-cryptography/coding-theory-and-applications/hamming-distance.html" class="internal-link" target="_self" rel="noopener nofollow">Hamming weight</a> over <img alt="left|invertbl" src="zz-allegati/quiver/quiversvg-20251223212352.svg" target="_self" style="width: 250px; max-width: 100%;"> There is a unique correspondence between and where
This bijection makes the following graph commute.
Then given we call ALgebraic normal form of the polynomial . Let , then the Algebraic degree of is the following
where is the correspondence relative to the algebraic normal form. Note
In the following we say that if . let be the correspondence relative to the algebraic normal form, then the following is a basis for as vector space To make the diagram commute and is linear.
This defines uniquely given with then given let then Via the definition of one finds that all the polynomial in there can be reduced to polynomials with component with degree not more than one, then via calculation one finds the basis . since we have that
Then
so must be linear, from this we have uniquely defined , however we should verify it is a bijection: since has a basis of cardinality we have
so we only neeed to verify is injective
Suppose to be mapped to the same , then
then for all , this means all its coefficients are zero, so as polynomials let Now
Then . <br><a data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean functions</a>
<br><a data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine boolean functions</a>
<br><a data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean functions</a>
<br><a data-href="Derivative of a boolean function" href="derivative-of-a-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Derivative of a boolean function</a>
<br><a data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean functions</a> <br><a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Dual Boolean function</a> <br><a data-href="Partially Bent boolean functions" href="partially-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Partially Bent boolean functions</a>
<br><a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Correlation immunity</a>
<br><a data-href="Algebraic immunity" href="algebraic-immunity.html" class="internal-link" target="_self" rel="noopener nofollow">Algebraic immunity</a>
<br><a data-href="Affine equivalence of boolean functions" href="affine-equivalence-of-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine equivalence of boolean functions</a>
]]></description><link>boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Boolean functions.md</guid><pubDate>Mon, 19 Jan 2026 13:54:49 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Bent vectorial boolean function]]></title><description><![CDATA[ Let a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a> then we define Let <br> a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>
<br> the <a data-tooltip-position="top" aria-label="Vectorial boolean function" data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-component function</a> of then the nonlinearity of is<br> where is the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Nonlinearity</a> of the <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">scalar boolean function</a>
Note
Using the <a data-href="characterization of nonlinearity" href="characterization-of-nonlinearity.html" class="internal-link" target="_self" rel="noopener nofollow">characterization of nonlinearity</a> for we get Let <br> a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>
<br> the <a data-tooltip-position="top" aria-label="Vectorial boolean function" data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-component function</a> of then is said to be bent if and only if<br>
in other terms if it meets the <a data-tooltip-position="top" aria-label="Covering bound theorem for boolean functions" data-href="Covering bound theorem for boolean functions" href="covering-bound-theorem-for-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">covering bound</a>
Note
this is equivalent to say that has at least one component meeting the bound Let a key an encryption function a random variable Then we define the event
and the linear bias
Which, trough some manipulations, gives We notice that for a random choice of we would get , so if we chose in such a way that we get an information we can exploit to recover the key .
This kind of attacks are called Linear attacks.
Note
The idea is that we want as big as possible, or equivalently as small as possible, because this way
So linear attacks are infeasible over <br>
Then the best choices for are bent boolean functions and <a data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost Bent vectorial Boolean functions</a>.
However it could be possible to split in small parts,assumed independent, that can be attacked via linear attascks. Characterization of bent vectorial boolean functions Let <br> the <a data-tooltip-position="top" aria-label="Vectorial boolean function" data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-component function</a> of Then the following are equivalent is bent
<br> is a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a>
<br> is a <a data-href="Balanced vectorial boolean function" href="balanced-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced vectorial boolean function</a> we know that one component is bent, so
but then<br>
but for <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a> we get that this must be an equality <br> from the <a data-href="Characterization of Bent boolean functions" href="characterization-of-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of Bent boolean functions</a> we get is a <a data-tooltip-position="top" aria-label="Balanced boolean functions" data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean function</a> for all .<br> So all the components of are <a data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean functions</a> and so is a <a data-href="Balanced vectorial boolean function" href="balanced-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced vectorial boolean function</a> <br> Since is balanced all its components are balanced, but then for <a data-href="Characterization of Bent boolean functions" href="characterization-of-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of Bent boolean functions</a> we get that all the components of are <a data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean functions</a>. Then is bent because it meets the <a data-tooltip-position="top" aria-label="Covering bound theorem for boolean functions" data-href="Covering bound theorem for boolean functions" href="covering-bound-theorem-for-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">covering bound</a>. <br> let a Bent <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then <br>Recall from <a data-tooltip-position="top" aria-label="Vectorial boolean function fibers characterization" data-href="Vectorial boolean function fibers characterization" href="vectorial-boolean-function-fibers-characterization.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of the fiber of vectorial boolean functions</a>
where .
<br>Observe that, since is a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a> we can consider its <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Dual Boolean function</a>, so Then Now is odd because for a and
clearly Then since we have , so ]]></description><link>bent-vectorial-boolean-function.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Bent vectorial boolean function.md</guid><pubDate>Mon, 19 Jan 2026 13:47:40 GMT</pubDate></item><item><title><![CDATA[Almost perfect nonlienar vectorial boolean functions]]></title><description><![CDATA[ Let the <a data-tooltip-position="top" aria-label="Derivative of a vectorial boolean function" data-href="Derivative of a vectorial boolean function" href="derivative-of-a-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Derivative of the vectorial boolean function</a> at then we define its differential uniformity to be<br> Note is always even because if is a solution for so is Let be a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then is called almost perfect nonlinear (APN) if Let a key an encryption function a random variable Then we define the event if we find such that then we can exploit it to deduce the original key for the cryptosystem, because for a random choice of we would have
This kind of attacks are are called DIfferential attacks
Note
The idea is that having as small as possible then
So the differential attacks are infeasible over .<br>
However it could be possible to split in small parts that have higher -uniformity, in this case one could mount an attack for example assuming each part is independent.
Important
An Example of Attack derived from differential attacks splitting the encryption is the <a data-tooltip-position="top" aria-label="Boomerang uniformity" data-href="Boomerang uniformity" href="boomerang-uniformity.html" class="internal-link" target="_self" rel="noopener nofollow">Boomerang differential attack</a>. <br>APN is -to-
Let a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then the following are equivalent <br> is an <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a> Since and is always even we have
Then Since we know for all , so Then the equality must hold, but it holds only if for every we have , so Characterization of APN functions via 2-dimensional subspaces<br>
Let a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then the following are equivalent <br> is an <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a>
for all a -dimensional affine subspace, then is not affine
For any the following holds Let , then is affine if and only if clearly if if affine , then consider , then
Then is linear, so is affine suppose exists an affine subset of dimension two such that is affine, then let where is a two dimensional vector subspace.
Then let , we have
so is constant over this subspace, then
this is a contradiction. we want to show the double implication of the direction is clear, we only have to deal with Let such that
Then consider the affine space , then if and we have an affine vector space of dimension and
then by the Lemma is affine, but this is a contradiction Then it is clear that suppose such that
then consider such that then , so
but so this is a contradiction
<br> We know from <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a> that
then the following hold if and only if is not affine over any -dimensional affine subspace
and if and only if this holds we have Characterization of almost bent vectorial boolean functions
Let odd <br> a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a> then the following are equivalent <br> is <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost bent</a>
<br> is an <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a> and <br> since is <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost bent</a> it meets the <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a>, so<br> This means that can't be affine over any assine subspace of dimension , the by <a data-href="Characterization of APN functions via 2-dimensional subspaces" href="characterization-of-apn-functions-via-2-dimensional-subspaces.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of APN functions via 2-dimensional subspaces</a> we have <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a>.
We also know the <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^3c45b7" data-href="010 - Exercises - Symmetric Cryptography#^3c45b7" href="010-exercises-symmetric-cryptography.html#^3c45b7" class="internal-link" target="_self" rel="noopener nofollow">walsh spectrum of almost bent functions</a> is . <br> we have to verify the conditions for <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a>, so <br> clearly for <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a> to hold Since is APN it is not affine over any 2-dimensional affine subspace, then Characterization of quadratic APN functions
Let odd
<br> a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>
<br>, so every component is a <a data-tooltip-position="top" aria-label="Quadratic boolean functions" data-href="Quadratic boolean functions" href="quadratic-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Quadratic boolean function</a> Then the following are equivalent <br> is <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a>
<br> is <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost bent</a> <br> Recall that is a <a data-tooltip-position="top" aria-label="Partially Bent boolean functions" data-href="Partially Bent boolean functions" href="partially-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Partially bent boolean function</a> since it is a <a data-tooltip-position="top" aria-label="Quadratic boolean functions" data-href="Quadratic boolean functions" href="quadratic-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Quadratic boolean function</a>. Then consider the subspace
This is the subspace where is affine. if then , then
Then there are such that exists , so
so , then<br>
This is impossible since is <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN</a> and then <br> is odd because in a complement of we can define the bent part of (as <a data-tooltip-position="top" aria-label="Partially Bent boolean functions" data-href="Partially Bent boolean functions" href="partially-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Partially bent boolean function</a>) so must be even. now let the <a data-tooltip-position="top" aria-label="Partially Bent boolean functions" data-href="Partially Bent boolean functions" href="partially-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Partially bent</a> decomposition of , with , then<br> Then is almost bent because it meets the <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a>. <br> clearly true for the <a data-href="Characterization of almost bent vectorial boolean functions" href="characterization-of-almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of almost bent vectorial boolean functions</a> Let <br> an APN <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a> then<br> Suppose then exists such that is affine then trough an affine trasformation <a data-href="Affine equivalence of boolean functions" href="affine-equivalence-of-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine equivalence of boolean functions</a> we get
So is constant over the first coordinate
so we consider given We observe that so is surjective, then<br>
so is <a data-tooltip-position="top" aria-label="Balanced vectorial boolean function" data-href="Balanced vectorial boolean function" href="balanced-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced</a> an so is <a data-tooltip-position="top" aria-label="Bent vectorial boolean function" data-href="Bent vectorial boolean function" href="bent-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Bent</a>. But then form the <a data-tooltip-position="top" aria-label="Bent vectorial boolean function > ^f3e1d7" data-href="Bent vectorial boolean function#^f3e1d7" href="bent-vectorial-boolean-function.html#^f3e1d7" class="internal-link" target="_self" rel="noopener nofollow">bentness image bound</a> we get <br><a data-href="Boomerang characterization of APN functions" href="boomerang-characterization-of-apn-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boomerang characterization of APN functions</a>
]]></description><link>almost-perfect-nonlienar-vectorial-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Almost perfect nonlienar vectorial boolean functions.md</guid><pubDate>Mon, 19 Jan 2026 11:42:19 GMT</pubDate></item><item><title><![CDATA[Characterization of Bent boolean functions]]></title><description><![CDATA[
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, then the following are equivalent <br> is a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a> for all <br>the <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bentness matrix</a> is Hadamard which means <br>The <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Sign matrix</a> is Hadamard, in particular <br>The <a data-tooltip-position="top" aria-label="Derivative of a boolean function" data-href="Derivative of a boolean function" href="derivative-of-a-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Derivative of the boolean function</a> is balanced at all , so<br> Note
For point it is clear that if is <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent</a> then it can't be <a data-tooltip-position="top" aria-label="Balanced boolean functions" data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced</a>, this because then for bentness, so there is an meeting this value. <br>
we know from <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a>
on the other hand from point we know But then the Parseval equality is met if and only if for all , then Recall
then is clear because . because the sum is commutative, then<br> then via <a data-tooltip-position="top" aria-label="Convolution formulas for Boolean Fourier transform" data-href="Convolution formulas for Boolean Fourier transform" href="convolution-formulas-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Walsh transposition formula</a> we observe then<br>
Now from <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^76473d" data-href="010 - Exercises - Symmetric Cryptography#^76473d" href="010-exercises-symmetric-cryptography.html#^76473d" class="internal-link" target="_self" rel="noopener nofollow">properties of the dual boolean function</a> we get
Then
so and is bent, so is Hadamard. is hadamard, then consider we have
then is balanced for all . We consider<br>
By the <a data-tooltip-position="top" aria-label="Derivative of a boolean function" data-href="Derivative of a boolean function" href="derivative-of-a-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of Boolean derivative</a> we get
So ]]></description><link>characterization-of-bent-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Characterization of Bent boolean functions.md</guid><pubDate>Sun, 18 Jan 2026 16:22:43 GMT</pubDate></item><item><title><![CDATA[010 - Exercises - Symmetric Cryptography]]></title><description><![CDATA[Shifted sequence
Let a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">linear sequence over the finite field</a> the minimal polynomial of the sequence obtained shifting by , such that the minimal polynomial of Then if is periodic then Note
This is equivalent to say
In particular in the case they are not the same it is because has some factor. let be a characteristic polynomial for , then clearly the recurrence holds also for , so is also a characteristic polynomial for , then because is a characteristic polynomial for . if is periodic then any characteristic polynomial for is also a characteristic polynomial for , indeed any recurrence for can be seen as a recurrence for from certain , but this meets the periodicity, so one finds out that the recurrence holds from the start. Then so . <br>Odd weight boolean functions
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, then Consider
we notice that
then we consider the bilinear form
we notice that
we also notice
Then so clearly is odd if and only if or equivalently . <br>Walsh transform of Let , then the <a data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Walsh transform</a> satisfies the following equality
In other words clearly for all , then clearly consider , clearly , then , so <br>Independent bent functions sum
Let be two <a data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean functions</a>, then consider
then is bent Now since they are bent functions they have walsh spectrum and respectively, so
this proves it is bent. Properties of the dual function
let <br> be a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a>
<br> be the <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">dual function</a> of Then is bent <br> Via <a data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Inversion formula for boolean Fourier transform</a> we have Fourier sum over subspace (NOT ASKED)
Let a linear subspace
<br> the orthogonal subspace under the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">boolean scalar product</a>
<br> the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Fourier transform over boolean functions</a> then<br> see <a data-href="Linear subspace formula for Boolean Fourier transform" href="linear-subspace-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Linear subspace formula for Boolean Fourier transform</a> Characterization of correlation immune functions
Let Then the following are equivalent <br> is -<a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-correlation immune</a> such that Characterization of correlation immunity
Let Then the following are equivalent <br> is <a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-correlation immune</a> s.t. consider a random variable uniformly distributed over , then with are two random variables, since is -correlation immune because we consider and , then
so with the function giving the sum of the components, then so <br>since is an <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine non trivial boolean function</a> it is balanced, so is uniformly distributed over if then we consider <br> fixed since for all we can use the <a data-href="Linear subspace formula for Boolean Fourier transform" href="linear-subspace-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Linear subspace formula for Boolean Fourier transform</a> and get
Then
now we recall then
the same is true for the conditioned probability, so we get Preserved by affine equivalence let be affine equivalent, then <br>the <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Algebraic degree of the boolean function|algebraic degree</a> is invariant <br>If then the following equation for the <a data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Walsh transform</a> holds The Walsh spectrum is invariant: <br>the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Nonlinearity</a> is invariant <br>if is a <a data-tooltip-position="top" aria-label="Balanced boolean functions" data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean function</a> then is also balanced
<br>the <a data-href="Algebraic immunity" href="algebraic-immunity.html" class="internal-link" target="_self" rel="noopener nofollow">Algebraic immunity</a> is invariant let , then
Then reducing trough the equivalences one gets that .
But then since is non singular we can work the other way around and get . we observe , then from the previous point is permuted in the by and is sign flipped by , but overall the Walsh spectrum is invariant. since the Walsh spectrum is invariant so is the nonlinearity let such that and and with minimal degree, then .
Then is a good choice for algebraic attacks over and the degree is preserved.
Then , but then we can wotj the other way around and get <br>Walsh spectrum of an almost bent function
Consider a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then the following are equivalent <br> is an <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost bent vecotrial boolean function</a> Notice that
So<br> Considering the proof of <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a> one should have
Now, since every element of the sum is non positive, for maximality of the factor, we get that every summand is null, so if for all we would have
but this is impossible. Then we have
from this <br>APN is -to-
Let a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then the following are equivalent <br> is an <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a> Since and is always even we have
Then Since we know for all , so Then the equality must hold, but it holds only if for every we have , so Question
Prove that a permutation with is 1-strongly anti-invariant if and only if has nonzero nonlinearity.
Where is strongly anti-invariant if there are no -dimensional subspaces and of such that Solution suppose , then there are such that
Then it is clear that , since is a permutation for cardinality reasons suppose there are subspaces with such that , then we consider
this is possible because .
clearly , so
viceversa if then and because is bijective, then , so Then it is clear that is affine, so ]]></description><link>010-exercises-symmetric-cryptography.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/010 - Exercises - Symmetric Cryptography.md</guid><pubDate>Fri, 16 Jan 2026 18:40:13 GMT</pubDate></item><item><title><![CDATA[Almost Bent vectorial Boolean functions]]></title><description><![CDATA[ Let with then This is a sketch proof.
We want to minimize , we consider the bound
for the denominator we can use <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a>, for the numerator we notice (via some calculations) From this one gets the wanted bound Note
The proof of this is easy but tedious, however the bound is met if and only if all the following are true <br> Important
It's important to remember that and so we only have to check for two of these Let a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, it is said to be Almost bent if Note
This functions meet the SCV bound, hence they have optimal nonlinearity <br>Walsh spectrum of an almost bent function
Consider a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then the following are equivalent <br> is an <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost bent vecotrial boolean function</a> Notice that
So<br> Considering the proof of <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a> one should have
Now, since every element of the sum is non positive, for maximality of the factor, we get that every summand is null, so if for all we would have
but this is impossible. Then we have
from this Characterization of almost bent vectorial boolean functions
Let odd <br> a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a> then the following are equivalent <br> is <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost bent</a>
<br> is an <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a> and <br> since is <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost bent</a> it meets the <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a>, so<br> This means that can't be affine over any assine subspace of dimension , the by <a data-href="Characterization of APN functions via 2-dimensional subspaces" href="characterization-of-apn-functions-via-2-dimensional-subspaces.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of APN functions via 2-dimensional subspaces</a> we have <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a>.
We also know the <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^3c45b7" data-href="010 - Exercises - Symmetric Cryptography#^3c45b7" href="010-exercises-symmetric-cryptography.html#^3c45b7" class="internal-link" target="_self" rel="noopener nofollow">walsh spectrum of almost bent functions</a> is . <br> we have to verify the conditions for <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a>, so <br> clearly for <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a> to hold Since is APN it is not affine over any 2-dimensional affine subspace, then ]]></description><link>almost-bent-vectorial-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Almost Bent vectorial Boolean functions.md</guid><pubDate>Fri, 16 Jan 2026 18:39:50 GMT</pubDate></item><item><title><![CDATA[Vectorial boolean function]]></title><description><![CDATA[
Let then is said to be a -vectorial boolean function. The set of such functions is denoted Let then it can be expressed as with for all Then the functions are said to be the coordinate functions of . Let Then we call -component function of the function Note
Clearly depends on the chosen basis over , this is not a problem in general, but we will see if it is useful to see and this isomorphism is dependent on the choice of a basis, in this case we must be careful with the basis choice and dependence Let the trace of an element of considered via the regular representation of . Then we call -trace component function of the function Important
The trace is a <a data-tooltip-position="top" aria-label="Forma Bilineare" data-href="Forma Bilineare" href="01-matematica/geometria-1b/forma-bilineare.html" class="internal-link" target="_self" rel="noopener nofollow">non degenerate bilinear form</a> over and , then it is possible to prove that under a well chosen base
Then under this base we have Note
While the scalar product is dependent on the chosen base the trace is not, so is not dependent on the base and for this reason it is useful Let it's -th component functions for <br> the <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Algebraic normal form for the boolean function</a> Then the algebraic normal form of is Then we can define the algebraic degree of as Note
It is clear that
so Let , we see then via interpolation there is only one polynomial such that
This polynomial form of is called Univatiate form of Important
The univariate form of is dependent on the indicization of independent to the choice of the base over Then we can calculate the trace components of via this univariate form independently form the choice of the base Let the univariate form of under lexicographic order Then Where is the weight of the binary representation of . Consider and it's binary wrtiting
we notice that since frobenius automorphism fixes coefficients, we have is linear, then
Then it is clrear Now we can consider and
then we define We have proved that now it is clear that they also have the sme dimension, then Vectorial boolean function fibers characterization
Let <br> the <a data-tooltip-position="top" aria-label="Vectorial boolean function" data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-component function</a> of for all Consider Then Note
This can be shown with the orthogonality of characters in a beautiful way We observe that <br><a data-href="Balanced vectorial boolean function" href="balanced-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced vectorial boolean function</a> <br><a data-href="characterization of balanced vectorial boolean functions" href="characterization-of-balanced-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">characterization of balanced vectorial boolean functions</a> <br><a data-href="Derivative of a vectorial boolean function" href="derivative-of-a-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Derivative of a vectorial boolean function</a>
<br><a data-href="Bent vectorial boolean function" href="bent-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Bent vectorial boolean function</a> <br><a data-href="Characterization of bent vectorial boolean functions" href="characterization-of-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of bent vectorial boolean functions</a> <br><a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost bent vecotrial boolean function</a> <br><a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a>
<br><a data-href="Characterization of almost bent vectorial boolean functions" href="characterization-of-almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of almost bent vectorial boolean functions</a> <br><a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a> <br><a data-href="Characterization of APN functions via 2-dimensional subspaces" href="characterization-of-apn-functions-via-2-dimensional-subspaces.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of APN functions via 2-dimensional subspaces</a>
<br><a data-href="Characterization of quadratic APN functions" href="characterization-of-quadratic-apn-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of quadratic APN functions</a> <br><a data-href="Boomerang uniformity" href="boomerang-uniformity.html" class="internal-link" target="_self" rel="noopener nofollow">Boomerang uniformity</a>
]]></description><link>vectorial-boolean-function.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Vectorial boolean function.md</guid><pubDate>Fri, 16 Jan 2026 18:39:38 GMT</pubDate></item><item><title><![CDATA[001 - Polynomial order and Sequences over finite fields]]></title><description><![CDATA[Polynomial order over a finite fields
Let be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> Then the order of over is Important
Later we will see that for irreducible there is a relationship between <br> Indeed (see <a data-tooltip-position="top" aria-label="Numero di polinomi irriducibili in un campo finito > ^05e4fe" data-href="Numero di polinomi irriducibili in un campo finito#^05e4fe" href="01-matematica/algebra-2/numero-di-polinomi-irriducibili-in-un-campo-finito#^05e4fe" class="internal-link" target="_self" rel="noopener nofollow">here</a>)<br>
viceversa (see <a data-tooltip-position="top" aria-label="Polynomial order over a finite fields > ^348b0e" data-href="Polynomial order over a finite fields#^348b0e" href="polynomial-order-over-a-finite-fields.html#^348b0e" class="internal-link" target="_self" rel="noopener nofollow">here</a>) if is a root of then Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> Then If is irreducible then if is a root of then if is not irreducible then one can consider with all the factors coprime one to the other, then if with the irreducible factors, then
where Let the -th cyclotomic polynomial
<br> a root of in it's splitting field Then, since is irreducible is the <a data-tooltip-position="top" aria-label="Numero di polinomi irriducibili in un campo finito" data-href="Numero di polinomi irriducibili in un campo finito" href="01-matematica/algebra-2/numero-di-polinomi-irriducibili-in-un-campo-finito" class="internal-link" target="_self" rel="noopener nofollow">Splitting field of</a> . For the same reason we know now in particular all the roots of must have the same order in because if it wasn't the case would have some roots in common with and some in common with now this means that splits over the irreducible factors of and which are clearly coprime, and this would contradict the irreducibility of .
Now and this is clearly minimal because of the minimality of the order. let , , because so
Now for the minimality of we have .
hence for minimality but is the hence let and .<br>
For what we have seen in <a data-tooltip-position="top" aria-label="Numero di polinomi irriducibili in un campo finito" data-href="Numero di polinomi irriducibili in un campo finito" href="01-matematica/algebra-2/numero-di-polinomi-irriducibili-in-un-campo-finito" class="internal-link" target="_self" rel="noopener nofollow">Splitting field of irreducibiles over finite fields</a> we have is one of the irreducible factors of without repetitions.
Then we consider , then Now let , hence if then , for coprimality of the two factors, thus , but here has no repetitions. This is a contradiction.
if then clearly hence . Then it's clear that
then for minimality Now for point we get
where Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> irreducible Then the following algorithm returns the order fo Algorithm Order of an irreducible fFq[x]f\in F_q[x]fFq[x] d:=degfd:=\deg fd:=degf e:=qd1e := q^d-1e:=qd1 (piai:i=1,,s)=(p_i^{a_i}: i=1,\ldots, s)=(piai:i=1,,s)= PrimeFactorization(eee) for i=1,,si=1,\ldots,si=1,,s do for j=1,,ajj=1,\ldots,a_jj=1,,aj do while xe/pi=1mod fx^{e/p_i}=1\mod fxe/pi=1modf do ee/pie \leftarrow e/p_iee/pi end while end for end for return eee Export to clipboard we are searching for the least divisor od such that
this works fine to find this leatt divisor and this clearly coresponds (for what seen before) to the order of . Sia <br> un <a data-href="Campo" href="01-matematica/geometria-1a/campo.html" class="internal-link" target="_self" rel="noopener nofollow">Campo</a> finito
<br>Sia un polinomio irriducibile, allora ne consideriamo l'<a data-tooltip-position="top" aria-label="Polynomial order over a finite fields" data-href="Polynomial order over a finite fields" href="polynomial-order-over-a-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">Ordine</a> Consideriamo Allora se allora Vale la seguente formula per (: sia una radice di , allora . Quindi , ma in particolare  il minimo tale che perch vive in ma in nessun sottocampo sottostante, questo perch  irriducibile, questo perch  il campo di spezzamento di , quindi aggiungere una radice vuol dire aggiungerle tutte.
Allora  il minimo per cui cio Sia l'-esimo polinomio ciclotomico, quindi chiaramente perch le sue radici sono tutte di ordine . D'altronde sappiamoc he , quinid in tutto abbiamo linear sequences over finite fields
Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> a sequence over Then is said to be -th linear sequence if there are for Then If then the sequence is said to be Homogeneous and is also called Linear feedback shift register (LFSR)
we call the initial state the vector we call -th state is the vector Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> a -th linear sequence Then one can rewrite the recurrence for in a matricial form over the states
where Important
If the linear sequence is homogeneous then we can drop the constant and get the matrix recursion
where
which is the companion matrix of the polynomial Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> a linear sequence over (period) Then is said to be ultimately periodic of period if exists such that Such is said to be the preperiod of is called the period
The minimum of all the possible periods is called the least perid generally noted as An ultimately periodic sequence with preperiod is said to be periodic Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> an ultimately periodic linear sequence the least period for a period for Then divides . We know then we consider where the rest of the integer division. Then
then is a period, hence which is a contradiction.
Hence , so . Let <br> a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> a -th linear sequence Then is ultimately periodic of period if is homogeneous then it is ultimately periodic of period if then is periodic of period consider this is the -th state, there are clearly only possible such states, so after iterations there will be a repetition of the state, hence a periodicity.
Then . we consider two cases if is an achieved state then , then
So is definitively zero, hence ultimately periodic with period .
if is not an achieved state then there are at most achieved states, then . if then is invertible, hence
so we consider the minimal preperiod and a period, then
this contradicts the minimality of the prerperiod, then Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> Then if is non singular is a period for is a companion matrix, if clearly all the columns are linearly independent, then is non singular. by definition of order if then So is a period for . <br><a data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characteristic polynomial for linear sequences</a> <br><a data-href="Characterization of the minimal polynomial for linear sequences" href="characterization-of-the-minimal-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of the minimal polynomial for linear sequences</a> Characteristic polynomial for linear sequences
Let <br> a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over the associated matrix to a linear recurrence for Then is a companion matrix for a polynomial , such polynomial is the characteristic polynomial of and is called the characteristic polynomial of Important
suppose to have the linear recurrence
then
indeed Let <br> a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over Then is called the minimal polynomial of if is a characteristic polynomial for if is a characteristic polynomial for then The feedback polynomial of a characteristic polynomial is the polynomial Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over be a characteristic polynomial of the associated companion matrix
<br> such that Then we know from the properties of <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> that in is a period for s, then is a period for since is a companion matrix is its characteristic polynomial but also its minimal polynomial, then
Then it is clear by minimality that . since is a period also is a period Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over <br> the <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Minimal polynomial for the linear sequence</a> Then <br> is a <a data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characteristic polynomial for linear sequences</a> if and only if The following is true: suppose , then and is a characteristic polynomial.
Then let Then applying this to the recursion, since is characteristic, we get
then clearly is a characteristic polynomial. Characterization of the minimal polynomial for linear sequences
Let <br> ne a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over <br> a <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characteristic polynomial for the linear sequence</a> Then we can consider the module , then the initial state is an element of this module and generates a submodule
since is the companion matrix of then is the minimal polynomial of , then , now via the structure theorem for finitely generated modules over PID we have
where is the prime factorization of .
Then is a module over that algebra, so we can split it in modules over the direct summands and get
where is a module, then
now the structure of the is easy to deduce, indeed are indecomposable. The indecomposable modules over are all of the form which corresponds in matrix form for to a companion matrix for .
More precisely since the module is cyclic also the submodules are cyclic because the projection over a submodule commutes with the multiplication by , then has the form of a companion matrix for over , so this module is irreducible.
Then the minimal polynomial for is the characteristic polynomial associated to the multicplication for in the so obtained module , which is the product of the . The matricial form for in this sumbmodule under a chosen base is a companion matrix for the given characteristic polynomial, this because the module is cyclic.
This means that Note
This gives us a way to construct the minimal polynomial and proves it's existence. Let and be characteristic polynomials of , then let be the associated matrices.
Then clearly then over the submodule the polynomial , this means that is divisible by the minimal polynomial defined as above, this because the characteristic polynomial in a cyclic submodule is the minimal polynomial of the associated matrix.
Now let be the minimal polynomial defined as above, then if is a characteristic polynomial and is the associated companion matrix, we have
This means that the linear recursion holds over the factors, hence is a characteristic polynomial for . Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over <br> a <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characteristic polynomial for the linear sequence</a> Then the following are equivalent The states are linearly independent
<br> is the <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Minimal polynomial for the linear sequence</a> we consider the module over where is the companion matrix associated to .
If are linearly independent then , this means that is the minimal polynomial by the previous characterization. is is the minimal polynomial then we consider the companion matrix for , if is not the whole space then is not the minimal polynomial because it admits a polynomial dividing it and generating , so must be linearly independent. Let a finite field
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a>
<br> the <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Minimal polynomial for the linear sequence</a> the least period for if then Since in the associated matrix we have , then
and this is a period, so , but on the other hand is a characteristic polynomial, so
then ]]></description><link>001-polynomial-order-and-sequences-over-finite-fields.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/001 - Polynomial order and Sequences over finite fields.md</guid><pubDate>Fri, 16 Jan 2026 16:50:33 GMT</pubDate></item><item><title><![CDATA[Quadratic boolean functions]]></title><description><![CDATA[
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, is said to be quadratic if , so The set of quadratic boolean functions ove is denoted as . Let a quadratic boolean functions, then <br> is a <a data-tooltip-position="top" aria-label="Partially Bent boolean functions" data-href="Partially Bent boolean functions" href="partially-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Partially bent boolean function</a> with splitting
where is sum of hyperbolic planes over and Let then We consider<br>
This is a bilinear form, clearly antisemitic because we are in , so via <a data-tooltip-position="top" aria-label="Base simplettica" data-href="Base simplettica" href="01-matematica/geometria-1b/base-simplettica.html" class="internal-link" target="_self" rel="noopener nofollow">sympletic decomposition</a> we get a splitting for Where is sum of hyperbolic planes. This is because
so if then must be constant.
Viceversa if is constant then for all , so This shows that is affine over and we set over we have<br>
so is affine nontrivial, so it is balanced. Then is <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent</a>. Moreover let then ]]></description><link>quadratic-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Quadratic boolean functions.md</guid><pubDate>Thu, 15 Jan 2026 07:06:58 GMT</pubDate></item><item><title><![CDATA[Characterization of almost bent vectorial boolean functions]]></title><description><![CDATA[
Let odd a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a> then the following are equivalent <br> is <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost bent</a>
<br> is an <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a> and <br> since is <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost bent</a> it meets the <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a>, so<br> This means that can't be affine over any assine subspace of dimension , the by <a data-href="Characterization of APN functions via 2-dimensional subspaces" href="characterization-of-apn-functions-via-2-dimensional-subspaces.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of APN functions via 2-dimensional subspaces</a> we have <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a>.
We also know the <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^3c45b7" data-href="010 - Exercises - Symmetric Cryptography#^3c45b7" href="010-exercises-symmetric-cryptography.html#^3c45b7" class="internal-link" target="_self" rel="noopener nofollow">walsh spectrum of almost bent functions</a> is . <br> we have to verify the conditions for <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a>, so <br> clearly for <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a> to hold Since is APN it is not affine over any 2-dimensional affine subspace, then ]]></description><link>characterization-of-almost-bent-vectorial-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Characterization of almost bent vectorial boolean functions.md</guid><pubDate>Wed, 14 Jan 2026 17:33:28 GMT</pubDate></item><item><title><![CDATA[Characterization of the minimal polynomial for linear sequences]]></title><description><![CDATA[
Let ne a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over <br> a <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characteristic polynomial for the linear sequence</a> Then we can consider the module , then the initial state is an element of this module and generates a submodule
since is the companion matrix of then is the minimal polynomial of , then , now via the structure theorem for finitely generated modules over PID we have
where is the prime factorization of .
Then is a module over that algebra, so we can split it in modules over the direct summands and get
where is a module, then
now the structure of the is easy to deduce, indeed are indecomposable. The indecomposable modules over are all of the form which corresponds in matrix form for to a companion matrix for .
More precisely since the module is cyclic also the submodules are cyclic because the projection over a submodule commutes with the multiplication by , then has the form of a companion matrix for over , so this module is irreducible.
Then the minimal polynomial for is the characteristic polynomial associated to the multicplication for in the so obtained module , which is the product of the . The matricial form for in this sumbmodule under a chosen base is a companion matrix for the given characteristic polynomial, this because the module is cyclic.
This means that Note
This gives us a way to construct the minimal polynomial and proves it's existence. Let and be characteristic polynomials of , then let be the associated matrices.
Then clearly then over the submodule the polynomial , this means that is divisible by the minimal polynomial defined as above, this because the characteristic polynomial in a cyclic submodule is the minimal polynomial of the associated matrix.
Now let be the minimal polynomial defined as above, then if is a characteristic polynomial and is the associated companion matrix, we have
This means that the linear recursion holds over the factors, hence is a characteristic polynomial for . Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over <br> a <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characteristic polynomial for the linear sequence</a> Then the following are equivalent The states are linearly independent
<br> is the <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Minimal polynomial for the linear sequence</a> we consider the module over where is the companion matrix associated to .
If are linearly independent then , this means that is the minimal polynomial by the previous characterization. is is the minimal polynomial then we consider the companion matrix for , if is not the whole space then is not the minimal polynomial because it admits a polynomial dividing it and generating , so must be linearly independent. ]]></description><link>characterization-of-the-minimal-polynomial-for-linear-sequences.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Characterization of the minimal polynomial for linear sequences.md</guid><pubDate>Wed, 14 Jan 2026 15:47:47 GMT</pubDate></item><item><title><![CDATA[Characterization of APN functions via 2-dimensional subspaces]]></title><description><![CDATA[
Let a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then the following are equivalent <br> is an <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a>
for all a -dimensional affine subspace, then is not affine
For any the following holds Let , then is affine if and only if clearly if if affine , then consider , then
Then is linear, so is affine suppose exists an affine subset of dimension two such that is affine, then let where is a two dimensional vector subspace.
Then let , we have
so is constant over this subspace, then
this is a contradiction. we want to show the double implication of the direction is clear, we only have to deal with Let such that
Then consider the affine space , then if and we have an affine vector space of dimension and
then by the Lemma is affine, but this is a contradiction Then it is clear that suppose such that
then consider such that then , so
but so this is a contradiction
<br> We know from <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a> that
then the following hold if and only if is not affine over any -dimensional affine subspace
and if and only if this holds we have ]]></description><link>characterization-of-apn-functions-via-2-dimensional-subspaces.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Characterization of APN functions via 2-dimensional subspaces.md</guid><pubDate>Tue, 13 Jan 2026 09:05:03 GMT</pubDate></item><item><title><![CDATA[Bent boolean functions]]></title><description><![CDATA[
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, then it is said to be bent if Note
This means that bent functions are the one meeting the <a data-tooltip-position="top" aria-label="Covering bound theorem for boolean functions" data-href="Covering bound theorem for boolean functions" href="covering-bound-theorem-for-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">covering bound</a>
So they have maximal nonlinearity.
However it is still to be proved that bent function actually exist, to do so we need an example:
Example
via computations one finds out
so and this means that More in general it is possible to prove that<br> is always bent trough <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^08961d" data-href="010 - Exercises - Symmetric Cryptography#^08961d" href="010-exercises-symmetric-cryptography.html#^08961d" class="internal-link" target="_self" rel="noopener nofollow">independent bent functions sum</a>. Let then we define the bentness matrix of as let then we define the sign matrix of as<br> Note
We will see in <a data-href="Characterization of Bent boolean functions" href="characterization-of-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of Bent boolean functions</a> that if is bent then<br> let be bent, then we define its dual function as or equivalently as the only <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> such that<br> Note
For some important properties of the dual function see <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^76473d" data-href="010 - Exercises - Symmetric Cryptography#^76473d" href="010-exercises-symmetric-cryptography.html#^76473d" class="internal-link" target="_self" rel="noopener nofollow">fundamental properties of dual functions</a> Properties of the dual function
let <br> be a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a>
<br> be the <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">dual function</a> of Then is bent <br> Via <a data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Inversion formula for boolean Fourier transform</a> we have Characterization of Bent boolean functions<br>
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, then the following are equivalent <br> is a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a> for all <br>the <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bentness matrix</a> is Hadamard which means <br>The <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Sign matrix</a> is Hadamard, in particular <br>The <a data-tooltip-position="top" aria-label="Derivative of a boolean function" data-href="Derivative of a boolean function" href="derivative-of-a-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Derivative of the boolean function</a> is balanced at all , so<br> Note
For point it is clear that if is <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent</a> then it can't be <a data-tooltip-position="top" aria-label="Balanced boolean functions" data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced</a>, this because then for bentness, so there is an meeting this value. <br>
we know from <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a>
on the other hand from point we know But then the Parseval equality is met if and only if for all , then Recall
then is clear because . because the sum is commutative, then<br> then via <a data-tooltip-position="top" aria-label="Convolution formulas for Boolean Fourier transform" data-href="Convolution formulas for Boolean Fourier transform" href="convolution-formulas-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Walsh transposition formula</a> we observe then<br>
Now from <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^76473d" data-href="010 - Exercises - Symmetric Cryptography#^76473d" href="010-exercises-symmetric-cryptography.html#^76473d" class="internal-link" target="_self" rel="noopener nofollow">properties of the dual boolean function</a> we get
Then
so and is bent, so is Hadamard. is hadamard, then consider we have
then is balanced for all . We consider<br>
By the <a data-tooltip-position="top" aria-label="Derivative of a boolean function" data-href="Derivative of a boolean function" href="derivative-of-a-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of Boolean derivative</a> we get
So let , then if is odd then then there is no such that and then can't be bent. Rothaus Bound for Bent boolean functiosn let , then Consider fixed, then<br>
this is clearly a subspace of dimension , then, thanking to <a data-href="Linear subspace formula for Boolean Fourier transform" href="linear-subspace-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Linear subspace formula for Boolean Fourier transform</a> we get
then
so if so
so ]]></description><link>bent-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Bent boolean functions.md</guid><pubDate>Fri, 09 Jan 2026 13:18:11 GMT</pubDate></item><item><title><![CDATA[Balanced boolean functions]]></title><description><![CDATA[
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, we say it is balanced if <br> Let an <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine boolean function</a>, then is balanced since is affine it can be written as<br>
with and , then we can suppose <a data-href="WLOG" href="01-matematica/algebra-1/wlog.html" class="internal-link" target="_self" rel="noopener nofollow">WLOG</a> , so
but so let balanced then <br> is not a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a> <br> From <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^cd13f0" data-href="010 - Exercises - Symmetric Cryptography#^cd13f0" href="010-exercises-symmetric-cryptography.html#^cd13f0" class="internal-link" target="_self" rel="noopener nofollow">exercise on odd weight boolean function</a> we can see that iff is odd, but then clearly can't be balanced. if is bent then for all , but then
Then Let then the following are equivalent is balanced
<br>The <a data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Walsh transform</a> in zero is zero then Let <br> two <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> a random variable uniformly distributed over Then if and only if is balanced
Let independent with balanced, then is balanced Then let , then
Then is balanced ]]></description><link>balanced-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Balanced boolean functions.md</guid><pubDate>Fri, 09 Jan 2026 13:18:11 GMT</pubDate></item><item><title><![CDATA[000 - Home - Symmetric cryptography and finite fields]]></title><description><![CDATA[ <a data-href="Polynomial order over a finite fields" href="polynomial-order-over-a-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">Polynomial order over a finite fields</a>
<br><a data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">linear sequences over finite fields</a>
<br><a data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characteristic polynomial for linear sequences</a> <br><a data-href="Characterization of the minimal polynomial for linear sequences" href="characterization-of-the-minimal-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of the minimal polynomial for linear sequences</a> <br><a data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean functions</a> <br><a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Algebraic normal form (ANF)</a> <br><a data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Walsh transform</a> <br><a data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Inversion formula for boolean Fourier transform</a>
<br><a data-href="Convolution formulas for Boolean Fourier transform" href="convolution-formulas-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Convolution formulas for Boolean Fourier transform</a>
<br><a data-href="Linear subspace formula for Boolean Fourier transform" href="linear-subspace-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Linear subspace formula for Boolean Fourier transform</a> <br><a data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine boolean functions</a> <br><a data-href="Characterization of affine boolean functions" href="characterization-of-affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of affine boolean functions</a>
<br><a data-href="characterization of nonlinearity" href="characterization-of-nonlinearity.html" class="internal-link" target="_self" rel="noopener nofollow">characterization of nonlinearity</a>
<br><a data-href="Covering bound theorem for boolean functions" href="covering-bound-theorem-for-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Covering bound theorem for boolean functions</a> <br><a data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean functions</a>
<br><a data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean functions</a> <br><a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^76473d" data-href="010 - Exercises - Symmetric Cryptography#^76473d" href="010-exercises-symmetric-cryptography.html#^76473d" class="internal-link" target="_self" rel="noopener nofollow">Dual boolean function</a>
<br><a data-href="Characterization of Bent boolean functions" href="characterization-of-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of Bent boolean functions</a> <br><a data-href="Partially Bent boolean functions" href="partially-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Partially Bent boolean functions</a>
<br><a data-href="Quadratic boolean functions" href="quadratic-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Quadratic boolean functions</a>
<br><a data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Correlation immune boolean function</a> <br><a data-href="Characterization of correlation immunity" href="characterization-of-correlation-immunity.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of correlation immunity</a>
<br><a data-href="Correlation immunity bounds" href="correlation-immunity-bounds.html" class="internal-link" target="_self" rel="noopener nofollow">Correlation immunity bounds</a> <br><a data-href="Algebraic immunity" href="algebraic-immunity.html" class="internal-link" target="_self" rel="noopener nofollow">Algebraic immunity</a>
<br><a data-href="Affine equivalence of boolean functions" href="affine-equivalence-of-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine equivalence of boolean functions</a> <br><a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a> <br><a data-tooltip-position="top" aria-label="Vectorial boolean function fibers characterization" data-href="Vectorial boolean function fibers characterization" href="vectorial-boolean-function-fibers-characterization.html" class="internal-link" target="_self" rel="noopener nofollow">Fiber formula for vectorial boolean functions</a> <br><a data-href="Balanced vectorial boolean function" href="balanced-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced vectorial boolean function</a> <br><a data-href="characterization of balanced vectorial boolean functions" href="characterization-of-balanced-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">characterization of balanced vectorial boolean functions</a> <br><a data-href="Derivative of a vectorial boolean function" href="derivative-of-a-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Derivative of a vectorial boolean function</a> <br><a data-tooltip-position="top" aria-label="Derivative of a boolean function" data-href="Derivative of a boolean function" href="derivative-of-a-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Derivative formula for boolean functions</a> <br><a data-href="Bent vectorial boolean function" href="bent-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Bent vectorial boolean function</a> <br><a data-href="Characterization of bent vectorial boolean functions" href="characterization-of-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of bent vectorial boolean functions</a> <br><a data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost Bent vectorial Boolean functions</a> <br><a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a>
<br><a data-href="Characterization of almost bent vectorial boolean functions" href="characterization-of-almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of almost bent vectorial boolean functions</a> <br><a data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost perfect nonlienar vectorial boolean functions</a> <br><a data-href="Characterization of APN functions via 2-dimensional subspaces" href="characterization-of-apn-functions-via-2-dimensional-subspaces.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of APN functions via 2-dimensional subspaces</a>
<br><a data-href="Characterization of quadratic APN functions" href="characterization-of-quadratic-apn-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of quadratic APN functions</a> <br><a data-href="Boomerang uniformity" href="boomerang-uniformity.html" class="internal-link" target="_self" rel="noopener nofollow">Boomerang uniformity</a> <br><a data-href="Boomerang characterization of APN functions" href="boomerang-characterization-of-apn-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boomerang characterization of APN functions</a> <br><a data-href="Characterization of correlation immunity" href="characterization-of-correlation-immunity.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of correlation immunity</a>
<br><a data-tooltip-position="top" aria-label="Affine equivalence of boolean functions > ^a78eb3" data-href="Affine equivalence of boolean functions#^a78eb3" href="affine-equivalence-of-boolean-functions.html#^a78eb3" class="internal-link" target="_self" rel="noopener nofollow">properties of affine equivalence</a> ]]></description><link>000-home-symmetric-cryptography-and-finite-fields.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/000 - Home - Symmetric cryptography and finite fields.md</guid><pubDate>Fri, 09 Jan 2026 13:18:11 GMT</pubDate></item><item><title><![CDATA[Rothaus Bound for Bent boolean functiosn]]></title><description><![CDATA[ let , then Consider fixed, then
this is clearly a subspace of dimension , then, thanking to <a data-href="Linear subspace formula for Boolean Fourier transform" href="linear-subspace-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Linear subspace formula for Boolean Fourier transform</a> we get
then
so if so
so ]]></description><link>rothaus-bound-for-bent-boolean-functiosn.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Rothaus Bound for Bent boolean functiosn.md</guid><pubDate>Mon, 05 Jan 2026 16:56:44 GMT</pubDate></item><item><title><![CDATA[Partially Bent boolean functions]]></title><description><![CDATA[
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, then is said partially bent if exists a linear splitting for such that <br> is an <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine boolean function</a> (in particular linear)
<br> is a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a> Then we can write for all Note
Since is bent over this means Let a partially bent boolean function with splitting , then for any consider and , then for any and we have Note
In general the subspace
is a set where is affine let then
then
so consider we denote and we denote and Then let , then let for which we consider where <br> the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine</a> part of which can be written as where is linear Then
So clearly let and with Then<br> This means that should be constant over , but is <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent</a>, so is balanced for any nonzero , so it can't be constant. Then meaning that Let be partially bent boolean function, consider with , then We observe that this because if this wasn't the case then for every we would have not balanced Then so we cosnder and Then ]]></description><link>partially-bent-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Partially Bent boolean functions.md</guid><pubDate>Sun, 04 Jan 2026 22:53:43 GMT</pubDate></item><item><title><![CDATA[Linear subspace formula for Boolean Fourier transform]]></title><description><![CDATA[
Let a non zero subspace the orthogonal subspace under the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">boolean scalar product</a>
<br> the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Fourier transform over boolean functions</a> then more in general, given we have Note
This theorem has a profound connection with characters and the definition of Fourier transform over groups. <br>
Observe that due to <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a> But then we calculate<br>
Since for <a data-tooltip-position="top" aria-label="Formula di Grassman" data-href="Formula di Grassman" href="01-matematica/geometria-1a/formula-di-grassman.html" class="internal-link" target="_self" rel="noopener nofollow">Grassman formula</a> , then if then if then Then , so But then we calculate we note then we get the conclusion. ]]></description><link>linear-subspace-formula-for-boolean-fourier-transform.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Linear subspace formula for Boolean Fourier transform.md</guid><pubDate>Sun, 04 Jan 2026 21:27:37 GMT</pubDate></item><item><title><![CDATA[Boomerang characterization of APN functions]]></title><description><![CDATA[
Let an invertible <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then the following are equivalent <br>the <a data-href="Boomerang uniformity" href="boomerang-uniformity.html" class="internal-link" target="_self" rel="noopener nofollow">Boomerang uniformity</a> of is minimal, so <br> is an <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a> <br> we know , then clearly is <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN</a> <br> for the <a data-href="Characterization of APN functions via 2-dimensional subspaces" href="characterization-of-apn-functions-via-2-dimensional-subspaces.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of APN functions via 2-dimensional subspaces</a> we have
we also know for Then clearly ]]></description><link>boomerang-characterization-of-apn-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Boomerang characterization of APN functions.md</guid><pubDate>Sun, 04 Jan 2026 04:06:19 GMT</pubDate></item><item><title><![CDATA[Boomerang uniformity]]></title><description><![CDATA[ Let a key an Encryption function such that a random variable Then we define the event
Chosen assuming the two parts of the encryption are independent one gets the following result over the <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Differential attack</a> for the subcryptosystems So if this quantity is we can exploit it to recover <br>
This kind of attacks are called Boomerang attacks.
Important
It is possible that the two parts we are splitting the systme into are not compatible in the sense that forevery then the probability of the single <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Differential attacks</a> is approximately zero, in this case we say that the two parts are incompatible because they give use scarse information.
One can solve this problem adding a middle part, so splitting
Then consider for , so
So if we know enough about we can calculate exactly and get the approximation for the boomerang attack. Let <br> an invertible <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a> a random variable Then we define Then we define the boomeran uniformity to be Note
The idea is that having as small as possible we get
so a boomerang attack is infeasible. Let <br> invertible <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>
<br> the <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Differential uniformity</a> of <br> the boomerang uniformity of Then Let a random variable, recall from <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Differential attack</a> that , then Then clearly , then <br> Let an invertible <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then let then
Consider , since is invertible this is uniformly distributed, then only calculations using Boomerang characterization of APN functions<br>
Let an invertible <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then the following are equivalent <br>the <a data-href="Boomerang uniformity" href="boomerang-uniformity.html" class="internal-link" target="_self" rel="noopener nofollow">Boomerang uniformity</a> of is minimal, so <br> is an <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a> <br> we know , then clearly is <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN</a> <br> for the <a data-href="Characterization of APN functions via 2-dimensional subspaces" href="characterization-of-apn-functions-via-2-dimensional-subspaces.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of APN functions via 2-dimensional subspaces</a> we have
we also know for Then clearly ]]></description><link>boomerang-uniformity.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Boomerang uniformity.md</guid><pubDate>Sun, 04 Jan 2026 03:57:15 GMT</pubDate></item><item><title><![CDATA[003 - Vectorial Boolean functions and their properties]]></title><link>003-vectorial-boolean-functions-and-their-properties.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/003 - Vectorial Boolean functions and their properties.md</guid><pubDate>Sun, 04 Jan 2026 01:11:38 GMT</pubDate></item><item><title><![CDATA[Derivative of a vectorial boolean function]]></title><description><![CDATA[
Let a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a> Then the boolean derivative of at is the functions defined as Let <br> a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>
<br> the <a data-tooltip-position="top" aria-label="Vectorial boolean function" data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-component function</a> of <br> the <a data-tooltip-position="top" aria-label="Derivative of a boolean function" data-href="Derivative of a boolean function" href="derivative-of-a-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Derivative of the boolean function</a> then Let <br> a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a> Then ]]></description><link>derivative-of-a-vectorial-boolean-function.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Derivative of a vectorial boolean function.md</guid><pubDate>Sun, 04 Jan 2026 01:09:19 GMT</pubDate></item><item><title><![CDATA[Derivative of a boolean function]]></title><description><![CDATA[
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> Then we define the boolean derivative of at to be the function such that Let <br> a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> the boolean derivative of at we define the function Then<br> Via <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a> we get<br> Then via <a data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Inversion formula for boolean Fourier transform</a> we get Observe<br>
Then from <a data-href="Convolution formulas for Boolean Fourier transform" href="convolution-formulas-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Convolution formulas for Boolean Fourier transform</a> ]]></description><link>derivative-of-a-boolean-function.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Derivative of a boolean function.md</guid><pubDate>Sat, 03 Jan 2026 07:34:09 GMT</pubDate></item><item><title><![CDATA[Characterization of quadratic APN functions]]></title><description><![CDATA[
Let odd a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>
<br>, so every component is a <a data-tooltip-position="top" aria-label="Quadratic boolean functions" data-href="Quadratic boolean functions" href="quadratic-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Quadratic boolean function</a> Then the following are equivalent <br> is <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN vectorial boolean function</a>
<br> is <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Almost bent</a> <br> Recall that is a <a data-tooltip-position="top" aria-label="Partially Bent boolean functions" data-href="Partially Bent boolean functions" href="partially-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Partially bent boolean function</a> since it is a <a data-tooltip-position="top" aria-label="Quadratic boolean functions" data-href="Quadratic boolean functions" href="quadratic-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Quadratic boolean function</a>. Then consider the subspace
This is the subspace where is affine. if then , then
Then there are such that exists , so
so , then<br>
This is impossible since is <a data-tooltip-position="top" aria-label="Almost perfect nonlienar vectorial boolean functions" data-href="Almost perfect nonlienar vectorial boolean functions" href="almost-perfect-nonlienar-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">APN</a> and then <br> is odd because in a complement of we can define the bent part of (as <a data-tooltip-position="top" aria-label="Partially Bent boolean functions" data-href="Partially Bent boolean functions" href="partially-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Partially bent boolean function</a>) so must be even. now let the <a data-tooltip-position="top" aria-label="Partially Bent boolean functions" data-href="Partially Bent boolean functions" href="partially-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Partially bent</a> decomposition of , with , then<br> Then is almost bent because it meets the <a data-tooltip-position="top" aria-label="Almost Bent vectorial Boolean functions" data-href="Almost Bent vectorial Boolean functions" href="almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">SCV Bound</a>. <br> clearly true for the <a data-href="Characterization of almost bent vectorial boolean functions" href="characterization-of-almost-bent-vectorial-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of almost bent vectorial boolean functions</a> ]]></description><link>characterization-of-quadratic-apn-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Characterization of quadratic APN functions.md</guid><pubDate>Sat, 03 Jan 2026 06:00:31 GMT</pubDate></item><item><title><![CDATA[002 - Boolean functions and their properties]]></title><description><![CDATA[Boolean functions
Let , then a Boolean function is a function The set of such functions is noted as . let then we define the evaluation of to be the vector
where is equipped with a fixed order for let then we define the weight of to be
where the right hand side is the <a data-tooltip-position="top" aria-label="Hamming distance" data-href="Hamming distance" href="05-cryptography/coding-theory-and-applications/hamming-distance.html" class="internal-link" target="_self" rel="noopener nofollow">Hamming weight</a> over <img alt="left|invertbl" src="zz-allegati/quiver/quiversvg-20251223212352.svg" target="_self" style="width: 250px; max-width: 100%;"> There is a unique correspondence between and where
This bijection makes the following graph commute.
Then given we call ALgebraic normal form of the polynomial . Let , then the Algebraic degree of is the following
where is the correspondence relative to the algebraic normal form. Note
In the following we say that if . let be the correspondence relative to the algebraic normal form, then the following is a basis for as vector space To make the diagram commute and is linear.
This defines uniquely given with then given let then Via the definition of one finds that all the polynomial in there can be reduced to polynomials with component with degree not more than one, then via calculation one finds the basis . since we have that
Then
so must be linear, from this we have uniquely defined , however we should verify it is a bijection: since has a basis of cardinality we have
so we only neeed to verify is injective
Suppose to be mapped to the same , then
then for all , this means all its coefficients are zero, so as polynomials let Now
Then . <br><a data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean functions</a>
<br><a data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine boolean functions</a>
<br><a data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean functions</a>
<br><a data-href="Derivative of a boolean function" href="derivative-of-a-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Derivative of a boolean function</a>
<br><a data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean functions</a> <br><a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Dual Boolean function</a> <br><a data-href="Partially Bent boolean functions" href="partially-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Partially Bent boolean functions</a>
<br><a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Correlation immunity</a>
<br><a data-href="Algebraic immunity" href="algebraic-immunity.html" class="internal-link" target="_self" rel="noopener nofollow">Algebraic immunity</a>
<br><a data-href="Affine equivalence of boolean functions" href="affine-equivalence-of-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine equivalence of boolean functions</a>
Walsh transform The fourier transfor is the map Where<br>
Where is the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">boolean scalar product</a>.
Note
Here the sum is in so we consider as a elements via the lifting
we call this lifting the standard lifting.
This way is a proper argoument for The Walsh transform is the map
where<br> where is the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">boolean scalar product</a>.
Note
We can observe that
where is defined as
or equivalently we consider as lifted via the standard lifting, then let then
so if observe that if then if then clearly Let then From this clearly derives the other equation. Inversion formula for boolean Fourier transform
Let , then<br> Note
If we can consider the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">standard lifting of F_2</a> and for it the equation above holds. Let then <br> Where the sums are all over so we are considering lifted by the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">standard lifting of F_2</a>. Convolution formulas for Boolean Fourier transform
Let <br> the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Fourier transform</a> operator we define the Boolean convolution as
Then<br> Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, then observe<br> Then via convolution formula and <a data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Inversion formula for boolean Fourier transform</a> we get But then Linear subspace formula for Boolean Fourier transform
Let a non zero subspace
<br> the orthogonal subspace under the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">boolean scalar product</a>
<br> the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Fourier transform over boolean functions</a> then more in general, given we have Note
This theorem has a profound connection with characters and the definition of Fourier transform over groups. <br>
Observe that due to <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a> But then we calculate<br>
Since for <a data-tooltip-position="top" aria-label="Formula di Grassman" data-href="Formula di Grassman" href="01-matematica/geometria-1a/formula-di-grassman.html" class="internal-link" target="_self" rel="noopener nofollow">Grassman formula</a> , then if then if then Then , so But then we calculate we note then we get the conclusion. Affine boolean functions<br>
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, it is called affine if The set of the affine boolean functions is noted as The most natural affine boolean function is induced by the boolean scalar product which is
then the map is an affine boolean function for all . let then we define Then we call nonlinearity of the following Characterization of affine boolean functions let , then exist such that
if then is said to be linear.
In particular there is a bijection , then<br> since the <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">ANF</a> form is in bijection with this induces the wanted bijection. characterization of nonlinearity Let <br> the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Nonlinearity</a> of Then we know<br>
now by <a data-href="Characterization of affine boolean functions" href="characterization-of-affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of affine boolean functions</a> this is equivalent to the following Covering bound theorem for boolean functions
Let even <br> the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Nonlinearity</a> of Then Note
This bound is known as the covering bound because it tells us that the Reed-Muller code<br>
since there are some functions that meet the covering bound this means that the bound gives us the minimal radius to generate a covering for the space eith <a data-tooltip-position="top" aria-label="Hamming distance" data-href="Hamming distance" href="05-cryptography/coding-theory-and-applications/hamming-distance.html" class="internal-link" target="_self" rel="noopener nofollow">Hamming balls</a> centered in point is . by the <a data-href="characterization of nonlinearity" href="characterization-of-nonlinearity.html" class="internal-link" target="_self" rel="noopener nofollow">characterization of nonlinearity</a><br>
Then we know via <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a>
so
then we get the wanted bound. Balanced boolean functions<br>
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, we say it is balanced if <br> Let an <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine boolean function</a>, then is balanced since is affine it can be written as<br>
with and , then we can suppose <a data-href="WLOG" href="01-matematica/algebra-1/wlog.html" class="internal-link" target="_self" rel="noopener nofollow">WLOG</a> , so
but so let balanced then <br> is not a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a> <br> From <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^cd13f0" data-href="010 - Exercises - Symmetric Cryptography#^cd13f0" href="010-exercises-symmetric-cryptography.html#^cd13f0" class="internal-link" target="_self" rel="noopener nofollow">exercise on odd weight boolean function</a> we can see that iff is odd, but then clearly can't be balanced. if is bent then for all , but then
Then Let then the following are equivalent is balanced
<br>The <a data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Walsh transform</a> in zero is zero then Let <br> two <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> a random variable uniformly distributed over Then if and only if is balanced
Let independent with balanced, then is balanced Then let , then
Then is balanced Derivative of a boolean function
Let <br> a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> Then we define the boolean derivative of at to be the function such that Let <br> a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> the boolean derivative of at we define the function Then<br> Via <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a> we get<br> Then via <a data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Inversion formula for boolean Fourier transform</a> we get Observe<br>
Then from <a data-href="Convolution formulas for Boolean Fourier transform" href="convolution-formulas-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Convolution formulas for Boolean Fourier transform</a> Bent boolean functions<br>
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, then it is said to be bent if Note
This means that bent functions are the one meeting the <a data-tooltip-position="top" aria-label="Covering bound theorem for boolean functions" data-href="Covering bound theorem for boolean functions" href="covering-bound-theorem-for-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">covering bound</a>
So they have maximal nonlinearity.
However it is still to be proved that bent function actually exist, to do so we need an example:
Example
via computations one finds out
so and this means that More in general it is possible to prove that<br> is always bent trough <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^08961d" data-href="010 - Exercises - Symmetric Cryptography#^08961d" href="010-exercises-symmetric-cryptography.html#^08961d" class="internal-link" target="_self" rel="noopener nofollow">independent bent functions sum</a>. Let then we define the bentness matrix of as let then we define the sign matrix of as<br> Note
We will see in <a data-href="Characterization of Bent boolean functions" href="characterization-of-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of Bent boolean functions</a> that if is bent then<br> let be bent, then we define its dual function as or equivalently as the only <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> such that<br> Note
For some important properties of the dual function see <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^76473d" data-href="010 - Exercises - Symmetric Cryptography#^76473d" href="010-exercises-symmetric-cryptography.html#^76473d" class="internal-link" target="_self" rel="noopener nofollow">fundamental properties of dual functions</a> Properties of the dual function
let <br> be a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a>
<br> be the <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">dual function</a> of Then is bent <br> Via <a data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Inversion formula for boolean Fourier transform</a> we have Characterization of Bent boolean functions<br>
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, then the following are equivalent <br> is a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a> for all <br>the <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bentness matrix</a> is Hadamard which means <br>The <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Sign matrix</a> is Hadamard, in particular <br>The <a data-tooltip-position="top" aria-label="Derivative of a boolean function" data-href="Derivative of a boolean function" href="derivative-of-a-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Derivative of the boolean function</a> is balanced at all , so<br> Note
For point it is clear that if is <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent</a> then it can't be <a data-tooltip-position="top" aria-label="Balanced boolean functions" data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced</a>, this because then for bentness, so there is an meeting this value. <br>
we know from <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a>
on the other hand from point we know But then the Parseval equality is met if and only if for all , then Recall
then is clear because . because the sum is commutative, then<br> then via <a data-tooltip-position="top" aria-label="Convolution formulas for Boolean Fourier transform" data-href="Convolution formulas for Boolean Fourier transform" href="convolution-formulas-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Walsh transposition formula</a> we observe then<br>
Now from <a data-tooltip-position="top" aria-label="010 - Exercises - Symmetric Cryptography > ^76473d" data-href="010 - Exercises - Symmetric Cryptography#^76473d" href="010-exercises-symmetric-cryptography.html#^76473d" class="internal-link" target="_self" rel="noopener nofollow">properties of the dual boolean function</a> we get
Then
so and is bent, so is Hadamard. is hadamard, then consider we have
then is balanced for all . We consider<br>
By the <a data-tooltip-position="top" aria-label="Derivative of a boolean function" data-href="Derivative of a boolean function" href="derivative-of-a-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of Boolean derivative</a> we get
So let , then if is odd then then there is no such that and then can't be bent. Rothaus Bound for Bent boolean functiosn let , then Consider fixed, then<br>
this is clearly a subspace of dimension , then, thanking to <a data-href="Linear subspace formula for Boolean Fourier transform" href="linear-subspace-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Linear subspace formula for Boolean Fourier transform</a> we get
then
so if so
so Partially Bent boolean functions<br>
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, then is said partially bent if exists a linear splitting for such that <br> is an <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine boolean function</a> (in particular linear)
<br> is a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a> Then we can write for all Note
Since is bent over this means Let a partially bent boolean function with splitting , then for any consider and , then for any and we have Note
In general the subspace
is a set where is affine let then
then
so consider we denote and we denote and Then let , then let for which we consider where <br> the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine</a> part of which can be written as where is linear Then
So clearly let and with Then<br> This means that should be constant over , but is <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent</a>, so is balanced for any nonzero , so it can't be constant. Then meaning that Let be partially bent boolean function, consider with , then We observe that this because if this wasn't the case then for every we would have not balanced Then so we cosnder and Then Quadratic boolean functions<br>
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, is said to be quadratic if , so The set of quadratic boolean functions ove is denoted as . Let a quadratic boolean functions, then <br> is a <a data-tooltip-position="top" aria-label="Partially Bent boolean functions" data-href="Partially Bent boolean functions" href="partially-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Partially bent boolean function</a> with splitting
where is sum of hyperbolic planes over and Let then We consider<br>
This is a bilinear form, clearly antisemitic because we are in , so via <a data-tooltip-position="top" aria-label="Base simplettica" data-href="Base simplettica" href="01-matematica/geometria-1b/base-simplettica.html" class="internal-link" target="_self" rel="noopener nofollow">sympletic decomposition</a> we get a splitting for Where is sum of hyperbolic planes. This is because
so if then must be constant.
Viceversa if is constant then for all , so This shows that is affine over and we set over we have<br>
so is affine nontrivial, so it is balanced. Then is <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent</a>. Moreover let then Correlation immune boolean function
Let <br> a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> a random variable uniformly distributed over then is said to be -correlation immune if
for all such that the following is true Note
This is equivalent to say
where is a random variable given via the conditioned probability: .
Moreover, since
we get is -correlation immune if and only if Let <br> a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> Then is said -resilient if is -correlation immune
<br> is a <a data-tooltip-position="top" aria-label="Balanced boolean functions" data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean function</a> Note
Observe that in this case
for every as above. Let a -correlation immune boolean function a random variable
For each with we define the random variable Then since
we know that since we know that then since all the events in then Characterization of correlation immunity
Let Then the following are equivalent <br> is <a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-correlation immune</a> s.t. consider a random variable uniformly distributed over , then with are two random variables, since is -correlation immune because we consider and , then
so with the function giving the sum of the components, then so <br>since is an <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine non trivial boolean function</a> it is balanced, so is uniformly distributed over if then we consider <br> fixed since for all we can use the <a data-href="Linear subspace formula for Boolean Fourier transform" href="linear-subspace-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Linear subspace formula for Boolean Fourier transform</a> and get
Then
now we recall then
the same is true for the conditioned probability, so we get Correlation immunity bounds
Let Then <br>
if is <a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-correlation immune</a> then <br>
if is <a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-resilient</a> then if then Important
We don't show the proof of these facts but they are important to know Algebraic immunity let , then This quantity gives a measure of resistance to algebraic attacks, which are attacks that exploit the equation Fast algebraic attack exploit equations of the type
because the multiplying by one gets Let , then <br> the let be the coefficients of the <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">ANF</a> of , then
then Let , then and , then
so this set is linear dependent since it exceeds the dimension, so there is of degree less the such that Affine equivalence of boolean functions
Let , then we say that they are affine equivalent and we write if exist an affine transformation of with such that let be affine equivalent, then <br>the <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Algebraic degree of the boolean function|algebraic degree</a> is invariant <br>If then the following equation for the <a data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Walsh transform</a> holds The Walsh spectrum is invariant: <br>the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Nonlinearity</a> is invariant <br>if is a <a data-tooltip-position="top" aria-label="Balanced boolean functions" data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean function</a> then is also balanced
<br>the <a data-href="Algebraic immunity" href="algebraic-immunity.html" class="internal-link" target="_self" rel="noopener nofollow">Algebraic immunity</a> is invariant let , then
Then reducing trough the equivalences one gets that .
But then since is non singular we can work the other way around and get . we observe , then from the previous point is permuted in the by and is sign flipped by , but overall the Walsh spectrum is invariant. since the Walsh spectrum is invariant so is the nonlinearity let such that and and with minimal degree, then .
Then is a good choice for algebraic attacks over and the degree is preserved.
Then , but then we can wotj the other way around and get ]]></description><link>002-boolean-functions-and-their-properties.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/002 - Boolean functions and their properties.md</guid><pubDate>Fri, 02 Jan 2026 19:01:33 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Vectorial boolean function fibers characterization]]></title><description><![CDATA[
Let the <a data-tooltip-position="top" aria-label="Vectorial boolean function" data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-component function</a> of for all Consider Then Note
This can be shown with the orthogonality of characters in a beautiful way We observe that ]]></description><link>vectorial-boolean-function-fibers-characterization.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Vectorial boolean function fibers characterization.md</guid><pubDate>Thu, 01 Jan 2026 19:15:15 GMT</pubDate></item><item><title><![CDATA[characterization of balanced vectorial boolean functions]]></title><description><![CDATA[ Let the <a data-tooltip-position="top" aria-label="Vectorial boolean function" data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-component function</a> of for each Consider the map
Then the following are equivalent is balanced for all <br> is balanced Recall the <a data-tooltip-position="top" aria-label="Vectorial boolean function fibers characterization" data-href="Vectorial boolean function fibers characterization" href="vectorial-boolean-function-fibers-characterization.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of the fiber of vectorial boolean functions</a>:
Then Then <br> by <a data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Inversion formula for boolean Fourier transform</a> So ]]></description><link>characterization-of-balanced-vectorial-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/characterization of balanced vectorial boolean functions.md</guid><pubDate>Wed, 31 Dec 2025 06:32:33 GMT</pubDate></item><item><title><![CDATA[Covering bound theorem for boolean functions]]></title><description><![CDATA[
Let even the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Nonlinearity</a> of Then Note
This bound is known as the covering bound because it tells us that the Reed-Muller code<br>
since there are some functions that meet the covering bound this means that the bound gives us the minimal radius to generate a covering for the space eith <a data-tooltip-position="top" aria-label="Hamming distance" data-href="Hamming distance" href="05-cryptography/coding-theory-and-applications/hamming-distance.html" class="internal-link" target="_self" rel="noopener nofollow">Hamming balls</a> centered in point is . by the <a data-href="characterization of nonlinearity" href="characterization-of-nonlinearity.html" class="internal-link" target="_self" rel="noopener nofollow">characterization of nonlinearity</a><br>
Then we know via <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a>
so
then we get the wanted bound. ]]></description><link>covering-bound-theorem-for-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Covering bound theorem for boolean functions.md</guid><pubDate>Wed, 31 Dec 2025 00:35:47 GMT</pubDate></item><item><title><![CDATA[Characterization of bent vectorial boolean functions]]></title><description><![CDATA[ Let the <a data-tooltip-position="top" aria-label="Vectorial boolean function" data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-component function</a> of Then the following are equivalent is bent
<br> is a <a data-tooltip-position="top" aria-label="Bent boolean functions" data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean function</a>
<br> is a <a data-href="Balanced vectorial boolean function" href="balanced-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced vectorial boolean function</a> we know that one component is bent, so
but then<br>
but for <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a> we get that this must be an equality <br> from the <a data-href="Characterization of Bent boolean functions" href="characterization-of-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of Bent boolean functions</a> we get is a <a data-tooltip-position="top" aria-label="Balanced boolean functions" data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean function</a> for all .<br> So all the components of are <a data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean functions</a> and so is a <a data-href="Balanced vectorial boolean function" href="balanced-vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced vectorial boolean function</a> <br> Since is balanced all its components are balanced, but then for <a data-href="Characterization of Bent boolean functions" href="characterization-of-bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of Bent boolean functions</a> we get that all the components of are <a data-href="Bent boolean functions" href="bent-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Bent boolean functions</a>. Then is bent because it meets the <a data-tooltip-position="top" aria-label="Covering bound theorem for boolean functions" data-href="Covering bound theorem for boolean functions" href="covering-bound-theorem-for-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">covering bound</a>. ]]></description><link>characterization-of-bent-vectorial-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Characterization of bent vectorial boolean functions.md</guid><pubDate>Wed, 31 Dec 2025 00:00:56 GMT</pubDate></item><item><title><![CDATA[Balanced vectorial boolean function]]></title><description><![CDATA[
Let a <a data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">Vectorial boolean function</a>, then is said to be balanced is Note
If then is balanced if and only if is a permutation of characterization of balanced vectorial boolean functions Let <br> the <a data-tooltip-position="top" aria-label="Vectorial boolean function" data-href="Vectorial boolean function" href="vectorial-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-component function</a> of for each Consider the map
Then the following are equivalent is balanced for all <br> is balanced Recall the <a data-tooltip-position="top" aria-label="Vectorial boolean function fibers characterization" data-href="Vectorial boolean function fibers characterization" href="vectorial-boolean-function-fibers-characterization.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of the fiber of vectorial boolean functions</a>:
Then Then <br> by <a data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Inversion formula for boolean Fourier transform</a> So ]]></description><link>balanced-vectorial-boolean-function.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Balanced vectorial boolean function.md</guid><pubDate>Wed, 31 Dec 2025 00:00:22 GMT</pubDate></item><item><title><![CDATA[Algebraic immunity]]></title><description><![CDATA[ let , then This quantity gives a measure of resistance to algebraic attacks, which are attacks that exploit the equation Fast algebraic attack exploit equations of the type
because the multiplying by one gets Let , then the let be the coefficients of the <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">ANF</a> of , then
then Let , then and , then
so this set is linear dependent since it exceeds the dimension, so there is of degree less the such that ]]></description><link>algebraic-immunity.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Algebraic immunity.md</guid><pubDate>Tue, 30 Dec 2025 15:53:32 GMT</pubDate></item><item><title><![CDATA[Affine equivalence of boolean functions]]></title><description><![CDATA[
Let , then we say that they are affine equivalent and we write if exist an affine transformation of with such that let be affine equivalent, then the <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Algebraic degree of the boolean function|algebraic degree</a> is invariant <br>If then the following equation for the <a data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Walsh transform</a> holds The Walsh spectrum is invariant: <br>the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Nonlinearity</a> is invariant <br>if is a <a data-tooltip-position="top" aria-label="Balanced boolean functions" data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean function</a> then is also balanced
<br>the <a data-href="Algebraic immunity" href="algebraic-immunity.html" class="internal-link" target="_self" rel="noopener nofollow">Algebraic immunity</a> is invariant let , then
Then reducing trough the equivalences one gets that .
But then since is non singular we can work the other way around and get . we observe , then from the previous point is permuted in the by and is sign flipped by , but overall the Walsh spectrum is invariant. since the Walsh spectrum is invariant so is the nonlinearity let such that and and with minimal degree, then .
Then is a good choice for algebraic attacks over and the degree is preserved.
Then , but then we can wotj the other way around and get ]]></description><link>affine-equivalence-of-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Affine equivalence of boolean functions.md</guid><pubDate>Mon, 29 Dec 2025 21:52:32 GMT</pubDate></item><item><title><![CDATA[Correlation immunity bounds]]></title><description><![CDATA[
Let Then if is <a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-correlation immune</a> then <br>
if is <a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-resilient</a> then if then Important
We don't show the proof of these facts but they are important to know ]]></description><link>correlation-immunity-bounds.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Correlation immunity bounds.md</guid><pubDate>Mon, 29 Dec 2025 19:46:14 GMT</pubDate></item><item><title><![CDATA[Correlation immune boolean function]]></title><description><![CDATA[
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> a random variable uniformly distributed over then is said to be -correlation immune if
for all such that the following is true Note
This is equivalent to say
where is a random variable given via the conditioned probability: .
Moreover, since
we get is -correlation immune if and only if Let <br> a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a> Then is said -resilient if is -correlation immune
<br> is a <a data-tooltip-position="top" aria-label="Balanced boolean functions" data-href="Balanced boolean functions" href="balanced-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Balanced boolean function</a> Note
Observe that in this case
for every as above. Let a -correlation immune boolean function a random variable
For each with we define the random variable Then since
we know that since we know that then since all the events in then Characterization of correlation immunity
Let Then the following are equivalent <br> is <a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-correlation immune</a> s.t. consider a random variable uniformly distributed over , then with are two random variables, since is -correlation immune because we consider and , then
so with the function giving the sum of the components, then so <br>since is an <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine non trivial boolean function</a> it is balanced, so is uniformly distributed over if then we consider <br> fixed since for all we can use the <a data-href="Linear subspace formula for Boolean Fourier transform" href="linear-subspace-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Linear subspace formula for Boolean Fourier transform</a> and get
Then
now we recall then
the same is true for the conditioned probability, so we get Correlation immunity bounds
Let Then <br>
if is <a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-correlation immune</a> then <br>
if is <a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-resilient</a> then if then Important
We don't show the proof of these facts but they are important to know ]]></description><link>correlation-immune-boolean-function.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Correlation immune boolean function.md</guid><pubDate>Mon, 29 Dec 2025 19:42:01 GMT</pubDate></item><item><title><![CDATA[Characterization of  correlation immunity]]></title><description><![CDATA[
Let Then the following are equivalent is <a data-tooltip-position="top" aria-label="Correlation immune boolean function" data-href="Correlation immune boolean function" href="correlation-immune-boolean-function.html" class="internal-link" target="_self" rel="noopener nofollow">-correlation immune</a> s.t. consider a random variable uniformly distributed over , then with are two random variables, since is -correlation immune because we consider and , then
so with the function giving the sum of the components, then so <br>since is an <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Affine non trivial boolean function</a> it is balanced, so is uniformly distributed over if then we consider <br> fixed since for all we can use the <a data-href="Linear subspace formula for Boolean Fourier transform" href="linear-subspace-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Linear subspace formula for Boolean Fourier transform</a> and get
Then
now we recall then
the same is true for the conditioned probability, so we get ]]></description><link>characterization-of-correlation-immunity.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Characterization of  correlation immunity.md</guid><pubDate>Mon, 29 Dec 2025 19:14:05 GMT</pubDate></item><item><title><![CDATA[Walsh transform]]></title><description><![CDATA[ The fourier transfor is the map Where
Where is the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">boolean scalar product</a>.
Note
Here the sum is in so we consider as a elements via the lifting
we call this lifting the standard lifting.
This way is a proper argoument for The Walsh transform is the map
where<br> where is the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">boolean scalar product</a>.
Note
We can observe that
where is defined as
or equivalently we consider as lifted via the standard lifting, then let then
so if observe that if then if then clearly Let then From this clearly derives the other equation. Inversion formula for boolean Fourier transform
Let , then<br> Note
If we can consider the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">standard lifting of F_2</a> and for it the equation above holds. Let then <br> Where the sums are all over so we are considering lifted by the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">standard lifting of F_2</a>. Convolution formulas for Boolean Fourier transform
Let <br> the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Fourier transform</a> operator we define the Boolean convolution as
Then<br> Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, then observe<br> Then via convolution formula and <a data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Inversion formula for boolean Fourier transform</a> we get But then Linear subspace formula for Boolean Fourier transform
Let a non zero subspace
<br> the orthogonal subspace under the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">boolean scalar product</a>
<br> the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Fourier transform over boolean functions</a> then more in general, given we have Note
This theorem has a profound connection with characters and the definition of Fourier transform over groups. <br>
Observe that due to <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a> But then we calculate<br>
Since for <a data-tooltip-position="top" aria-label="Formula di Grassman" data-href="Formula di Grassman" href="01-matematica/geometria-1a/formula-di-grassman.html" class="internal-link" target="_self" rel="noopener nofollow">Grassman formula</a> , then if then if then Then , so But then we calculate we note then we get the conclusion. ]]></description><link>walsh-transform.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Walsh transform.md</guid><pubDate>Mon, 29 Dec 2025 03:12:04 GMT</pubDate></item><item><title><![CDATA[Convolution formulas for Boolean Fourier transform]]></title><description><![CDATA[
Let the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Fourier transform</a> operator we define the Boolean convolution as
Then<br> Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, then observe<br> Then via convolution formula and <a data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Inversion formula for boolean Fourier transform</a> we get But then ]]></description><link>convolution-formulas-for-boolean-fourier-transform.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Convolution formulas for Boolean Fourier transform.md</guid><pubDate>Sun, 28 Dec 2025 23:20:33 GMT</pubDate></item><item><title><![CDATA[Affine boolean functions]]></title><description><![CDATA[
Let a <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean function</a>, it is called affine if The set of the affine boolean functions is noted as The most natural affine boolean function is induced by the boolean scalar product which is
then the map is an affine boolean function for all . let then we define Then we call nonlinearity of the following Characterization of affine boolean functions let , then exist such that
if then is said to be linear.
In particular there is a bijection , then<br> since the <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">ANF</a> form is in bijection with this induces the wanted bijection. characterization of nonlinearity Let <br> the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Nonlinearity</a> of Then we know<br>
now by <a data-href="Characterization of affine boolean functions" href="characterization-of-affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of affine boolean functions</a> this is equivalent to the following Covering bound theorem for boolean functions
Let even <br> the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Nonlinearity</a> of Then Note
This bound is known as the covering bound because it tells us that the Reed-Muller code<br>
since there are some functions that meet the covering bound this means that the bound gives us the minimal radius to generate a covering for the space eith <a data-tooltip-position="top" aria-label="Hamming distance" data-href="Hamming distance" href="05-cryptography/coding-theory-and-applications/hamming-distance.html" class="internal-link" target="_self" rel="noopener nofollow">Hamming balls</a> centered in point is . by the <a data-href="characterization of nonlinearity" href="characterization-of-nonlinearity.html" class="internal-link" target="_self" rel="noopener nofollow">characterization of nonlinearity</a><br>
Then we know via <a data-tooltip-position="top" aria-label="Inversion formula for boolean Fourier transform" data-href="Inversion formula for boolean Fourier transform" href="inversion-formula-for-boolean-fourier-transform.html" class="internal-link" target="_self" rel="noopener nofollow">Boolean Parseval equality</a>
so
then we get the wanted bound. ]]></description><link>affine-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Affine boolean functions.md</guid><pubDate>Sun, 28 Dec 2025 19:57:39 GMT</pubDate></item><item><title><![CDATA[Inversion formula for boolean Fourier transform]]></title><description><![CDATA[
Let , then Note
If we can consider the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">standard lifting of F_2</a> and for it the equation above holds. Let then <br> Where the sums are all over so we are considering lifted by the <a data-tooltip-position="top" aria-label="Walsh transform" data-href="Walsh transform" href="walsh-transform.html" class="internal-link" target="_self" rel="noopener nofollow">standard lifting of F_2</a>. ]]></description><link>inversion-formula-for-boolean-fourier-transform.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Inversion formula for boolean Fourier transform.md</guid><pubDate>Sun, 28 Dec 2025 19:27:55 GMT</pubDate></item><item><title><![CDATA[Characterization of affine boolean functions]]></title><description><![CDATA[ let , then exist such that
if then is said to be linear.
In particular there is a bijection , then since the <a data-tooltip-position="top" aria-label="Boolean functions" data-href="Boolean functions" href="boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">ANF</a> form is in bijection with this induces the wanted bijection. ]]></description><link>characterization-of-affine-boolean-functions.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Characterization of affine boolean functions.md</guid><pubDate>Sun, 28 Dec 2025 18:18:09 GMT</pubDate></item><item><title><![CDATA[characterization of nonlinearity]]></title><description><![CDATA[ Let the <a data-tooltip-position="top" aria-label="Affine boolean functions" data-href="Affine boolean functions" href="affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Nonlinearity</a> of Then we know<br>
now by <a data-href="Characterization of affine boolean functions" href="characterization-of-affine-boolean-functions.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of affine boolean functions</a> this is equivalent to the following ]]></description><link>characterization-of-nonlinearity.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/characterization of nonlinearity.md</guid><pubDate>Sun, 28 Dec 2025 18:10:29 GMT</pubDate></item><item><title><![CDATA[Characteristic polynomial for linear sequences]]></title><description><![CDATA[
Let a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over the associated matrix to a linear recurrence for Then is a companion matrix for a polynomial , such polynomial is the characteristic polynomial of and is called the characteristic polynomial of Important
suppose to have the linear recurrence
then
indeed Let <br> a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over Then is called the minimal polynomial of if is a characteristic polynomial for if is a characteristic polynomial for then The feedback polynomial of a characteristic polynomial is the polynomial Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over be a characteristic polynomial of the associated companion matrix
<br> such that Then we know from the properties of <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> that in is a period for s, then is a period for since is a companion matrix is its characteristic polynomial but also its minimal polynomial, then
Then it is clear by minimality that . since is a period also is a period Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over <br> the <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Minimal polynomial for the linear sequence</a> Then <br> is a <a data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characteristic polynomial for linear sequences</a> if and only if The following is true: suppose , then and is a characteristic polynomial.
Then let Then applying this to the recursion, since is characteristic, we get
then clearly is a characteristic polynomial. Characterization of the minimal polynomial for linear sequences
Let <br> ne a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over <br> a <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characteristic polynomial for the linear sequence</a> Then we can consider the module , then the initial state is an element of this module and generates a submodule
since is the companion matrix of then is the minimal polynomial of , then , now via the structure theorem for finitely generated modules over PID we have
where is the prime factorization of .
Then is a module over that algebra, so we can split it in modules over the direct summands and get
where is a module, then
now the structure of the is easy to deduce, indeed are indecomposable. The indecomposable modules over are all of the form which corresponds in matrix form for to a companion matrix for .
More precisely since the module is cyclic also the submodules are cyclic because the projection over a submodule commutes with the multiplication by , then has the form of a companion matrix for over , so this module is irreducible.
Then the minimal polynomial for is the characteristic polynomial associated to the multicplication for in the so obtained module , which is the product of the . The matricial form for in this sumbmodule under a chosen base is a companion matrix for the given characteristic polynomial, this because the module is cyclic.
This means that Note
This gives us a way to construct the minimal polynomial and proves it's existence. Let and be characteristic polynomials of , then let be the associated matrices.
Then clearly then over the submodule the polynomial , this means that is divisible by the minimal polynomial defined as above, this because the characteristic polynomial in a cyclic submodule is the minimal polynomial of the associated matrix.
Now let be the minimal polynomial defined as above, then if is a characteristic polynomial and is the associated companion matrix, we have
This means that the linear recursion holds over the factors, hence is a characteristic polynomial for . Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> over <br> a <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characteristic polynomial for the linear sequence</a> Then the following are equivalent The states are linearly independent
<br> is the <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Minimal polynomial for the linear sequence</a> we consider the module over where is the companion matrix associated to .
If are linearly independent then , this means that is the minimal polynomial by the previous characterization. is is the minimal polynomial then we consider the companion matrix for , if is not the whole space then is not the minimal polynomial because it admits a polynomial dividing it and generating , so must be linearly independent. Let a finite field
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a>
<br> the <a data-tooltip-position="top" aria-label="Characteristic polynomial for linear sequences" data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Minimal polynomial for the linear sequence</a> the least period for if then Since in the associated matrix we have , then
and this is a period, so , but on the other hand is a characteristic polynomial, so
then ]]></description><link>characteristic-polynomial-for-linear-sequences.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Characteristic polynomial for linear sequences.md</guid><pubDate>Sun, 21 Dec 2025 01:08:07 GMT</pubDate></item><item><title><![CDATA[linear sequences over finite fields]]></title><description><![CDATA[
Let be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> a sequence over Then is said to be -th linear sequence if there are for Then If then the sequence is said to be Homogeneous and is also called Linear feedback shift register (LFSR)
we call the initial state the vector we call -th state is the vector Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> a -th linear sequence Then one can rewrite the recurrence for in a matricial form over the states
where Important
If the linear sequence is homogeneous then we can drop the constant and get the matrix recursion
where
which is the companion matrix of the polynomial Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> a linear sequence over (period) Then is said to be ultimately periodic of period if exists such that Such is said to be the preperiod of is called the period
The minimum of all the possible periods is called the least perid generally noted as An ultimately periodic sequence with preperiod is said to be periodic Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> an ultimately periodic linear sequence the least period for a period for Then divides . We know then we consider where the rest of the integer division. Then
then is a period, hence which is a contradiction.
Hence , so . Let <br> a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> a -th linear sequence Then is ultimately periodic of period if is homogeneous then it is ultimately periodic of period if then is periodic of period consider this is the -th state, there are clearly only possible such states, so after iterations there will be a repetition of the state, hence a periodicity.
Then . we consider two cases if is an achieved state then , then
So is definitively zero, hence ultimately periodic with period .
if is not an achieved state then there are at most achieved states, then . if then is invertible, hence
so we consider the minimal preperiod and a period, then
this contradicts the minimality of the prerperiod, then Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a>
<br> a <a data-tooltip-position="top" aria-label="linear sequences over finite fields" data-href="linear sequences over finite fields" href="linear-sequences-over-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">LFSR</a> Then if is non singular is a period for is a companion matrix, if clearly all the columns are linearly independent, then is non singular. by definition of order if then So is a period for . <br><a data-href="Characteristic polynomial for linear sequences" href="characteristic-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characteristic polynomial for linear sequences</a> <br><a data-href="Characterization of the minimal polynomial for linear sequences" href="characterization-of-the-minimal-polynomial-for-linear-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Characterization of the minimal polynomial for linear sequences</a> ]]></description><link>linear-sequences-over-finite-fields.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/linear sequences over finite fields.md</guid><pubDate>Sat, 20 Dec 2025 16:10:23 GMT</pubDate></item><item><title><![CDATA[Polynomial order over a finite fields]]></title><description><![CDATA[
Let be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> Then the order of over is Important
Later we will see that for irreducible there is a relationship between <br> Indeed (see <a data-tooltip-position="top" aria-label="Numero di polinomi irriducibili in un campo finito > ^05e4fe" data-href="Numero di polinomi irriducibili in un campo finito#^05e4fe" href="01-matematica/algebra-2/numero-di-polinomi-irriducibili-in-un-campo-finito#^05e4fe" class="internal-link" target="_self" rel="noopener nofollow">here</a>)<br>
viceversa (see <a data-tooltip-position="top" aria-label="Polynomial order over a finite fields > ^348b0e" data-href="Polynomial order over a finite fields#^348b0e" href="polynomial-order-over-a-finite-fields.html#^348b0e" class="internal-link" target="_self" rel="noopener nofollow">here</a>) if is a root of then Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> Then If is irreducible then if is a root of then if is not irreducible then one can consider with all the factors coprime one to the other, then if with the irreducible factors, then
where Let the -th cyclotomic polynomial
<br> a root of in it's splitting field Then, since is irreducible is the <a data-tooltip-position="top" aria-label="Numero di polinomi irriducibili in un campo finito" data-href="Numero di polinomi irriducibili in un campo finito" href="01-matematica/algebra-2/numero-di-polinomi-irriducibili-in-un-campo-finito" class="internal-link" target="_self" rel="noopener nofollow">Splitting field of</a> . For the same reason we know now in particular all the roots of must have the same order in because if it wasn't the case would have some roots in common with and some in common with now this means that splits over the irreducible factors of and which are clearly coprime, and this would contradict the irreducibility of .
Now and this is clearly minimal because of the minimality of the order. let , , because so
Now for the minimality of we have .
hence for minimality but is the hence let and .<br>
For what we have seen in <a data-tooltip-position="top" aria-label="Numero di polinomi irriducibili in un campo finito" data-href="Numero di polinomi irriducibili in un campo finito" href="01-matematica/algebra-2/numero-di-polinomi-irriducibili-in-un-campo-finito" class="internal-link" target="_self" rel="noopener nofollow">Splitting field of irreducibiles over finite fields</a> we have is one of the irreducible factors of without repetitions.
Then we consider , then Now let , hence if then , for coprimality of the two factors, thus , but here has no repetitions. This is a contradiction.
if then clearly hence . Then it's clear that
then for minimality Now for point we get
where Let <br> be a <a data-tooltip-position="top" aria-label="Teorema di classificazione dei campi finiti" data-href="Teorema di classificazione dei campi finiti" href="01-matematica/algebra-2/teorema-di-classificazione-dei-campi-finiti.html" class="internal-link" target="_self" rel="noopener nofollow">Finite field</a> irreducible Then the following algorithm returns the order fo Algorithm Order of an irreducible fFq[x]f\in F_q[x]fFq[x] d:=degfd:=\deg fd:=degf e:=qd1e := q^d-1e:=qd1 (piai:i=1,,s)=(p_i^{a_i}: i=1,\ldots, s)=(piai:i=1,,s)= PrimeFactorization(eee) for i=1,,si=1,\ldots,si=1,,s do for j=1,,ajj=1,\ldots,a_jj=1,,aj do while xe/pi=1mod fx^{e/p_i}=1\mod fxe/pi=1modf do ee/pie \leftarrow e/p_iee/pi end while end for end for return eee Export to clipboard we are searching for the least divisor od such that
this works fine to find this leatt divisor and this clearly coresponds (for what seen before) to the order of . Sia <br> un <a data-href="Campo" href="01-matematica/geometria-1a/campo.html" class="internal-link" target="_self" rel="noopener nofollow">Campo</a> finito
<br>Sia un polinomio irriducibile, allora ne consideriamo l'<a data-tooltip-position="top" aria-label="Polynomial order over a finite fields" data-href="Polynomial order over a finite fields" href="polynomial-order-over-a-finite-fields.html" class="internal-link" target="_self" rel="noopener nofollow">Ordine</a> Consideriamo Allora se allora Vale la seguente formula per (: sia una radice di , allora . Quindi , ma in particolare  il minimo tale che perch vive in ma in nessun sottocampo sottostante, questo perch  irriducibile, questo perch  il campo di spezzamento di , quindi aggiungere una radice vuol dire aggiungerle tutte.
Allora  il minimo per cui cio Sia l'-esimo polinomio ciclotomico, quindi chiaramente perch le sue radici sono tutte di ordine . D'altronde sappiamoc he , quinid in tutto abbiamo ]]></description><link>polynomial-order-over-a-finite-fields.html</link><guid isPermaLink="false">05 - Cryptography/Symmetric cryptography and finite fields/Polynomial order over a finite fields.md</guid><pubDate>Sun, 12 Oct 2025 14:42:50 GMT</pubDate></item></channel></rss>